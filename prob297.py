# Zeckendorf terms 
#   https://oeis.org/A007895
# Cumsum of above
#   https://oeis.org/A179180
""" 

Each new term in the Fibonacci sequence is generated by adding the
previous two terms.  Starting with 1 and 2, the first 10 terms will be: 1,
2, 3, 5, 8, 13, 21, 34, 55, 89.

Every positive integer can be uniquely written as a sum of nonconsecutive
terms of the Fibonacci sequence. For example, 100 = 3 + 8 + 89.  Such a
sum is called the Zeckendorf representation of the number.

...
"""
import euler
import itertools

@euler.in_mem_memoize
def zfib(n):
    assert(n >= 1)
    if n == 1 or n == 2:
        return n
    return zfib(n-1) + zfib(n-2)

def zeckendorf(n):
    # zeckendofr representation of n (write n as a sum of 
    # non-consecutive Fibonacci numbers). See A007895
    if n == 0:
        return 0
    else:
        for i in itertools.count(start=2):
            if zfib(i) > n:
                return 1 + zeckendorf(n - zfib(i-1))
    assert(1==0)

def testcase1():
    cnt = 0
    for i in xrange(1, 10**6):
        z = zeckendorf(i)
        cnt += z
    assert cnt == 7894453

def main():
    cnt = 0
    for i in xrange(1, 10**4):
        z = zeckendorf(i)
        cnt += z
        print i, cnt

def f(lst):
    return [i+1 for i in lst]

@euler.in_mem_memoize
def cumzeck(n):
    # with lists
    if n == 1 or n == 2:
        return [1]
    else:
        return cumzeck(n-1) + f(cumzeck(n-2))

@euler.in_mem_memoize
def cz2(n): # Int -> (Length : Int, Sum : Int)
    # just with (len, sum)
    if n == 1 or n == 2:
        return (1, 1)
    else:
        a = cz2(n - 1)
        b = cz2(n - 2)
        bnew = (b[0], b[1] + b[0])
        return (a[0] + bnew[0], a[1] + bnew[1])


for i in xrange(2,84):
    print cz2(i)
