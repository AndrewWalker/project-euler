# Project Euler Hints

This is the list of stuff that I wish someone had told me when I was
getting started with Project Euler (PE)


## General Hints

### Pick a language that has built in big nums as first class types. 

You can thank me later ...

### When you solve a problem read the forum posts

Omg. So many hints

This is also a really good way to see how people were able to get to the
solutuon - it's a good way to learn how other people did things.

If you've struggled, it's also a good way to see if anyone else had
problems



## Jump in and Have a Go

Have a go, do five problems and see how long it takes, be aware that the
first five problems might take an hour, but fifty might take six months

### Know what you want to get out of the site 

Decide what is fair and reasonable research, compared to regurgitating
someone else's solution. For me, this means

- Wikipedia is great 
- Structure and Interpretation of Computer Programs (SICP) is great
- Blogs are OK so long as they don't refer to PE

### Set a target

Can you do 5? 10? 50? At some point this seemed to lose importance - the
task is more than how many you've done

### Always. Always read the question

So much time wasted by not doing this. If the problem description says
count. Count, don't build a list of the things you're counting.




## Keep your answers

Many of the problems build on the work of previous questions, keeping your
files helps you keep track of what you've done before - "it might be one
of these" identifications - can you rule some things out

### Make a library

Once you've got a few things you've copied and pasted in, refactor them to a library. This makes it easier and faster to improve and reuse code

### Write some tests 

If you're going to have reusable code, make sure it's right by using tests 

### Write the naive (slow obvious) version first. 

Keep it, they make good test case validators

### Keep your answers in version control

If it ain't in version control, it ain't done

It might not sound important, but there are 450+ problems some of which
may take days to finish (or in one case for me years). You're going to
want to make changes and roll back from time to time

This is especially important if you're working on solutions on different
machines

### Put your solutions in the cloud

You want access to your solutions everywhere / seamless syncing to pick up
from where you left off

Bitbucket / GitHub both work (depending how nice your code is you might
want to keep it private), but it's also closer to the site "rules" to make
it private 



## Know when to give up

You won't know how to solve all the problems - PE does a pretty good job
of preparing you to solve most of them though

### Don't be ashamed to do the easy problems first 

Which could equally be stated as, skip problems if you're stuck

Some of the problems are hard and unfamiliar if your background isn't math
- sometimes you'll need to come back to something

### Steal code

Stuck on prime numbers? Totients? Steal someone else's implementation (so
long as the license is ok of course)

### Use a tool

Mathematica may not be a panacea, but it's amazing for prototyping and
checking algebra and graph theory.  If you're cheap, use Wolfram Alpha

### Use a library

Once you know what you're looking for, pick a (good) library for symbolic math / number theory. Use it. It's probably much faster and better than your code



## Document

My gaps between attempts at problems can be in the order of years
(Christmas coding breaks!). It's nice to know what worked (and what
didn't) from last time you tried.

It also helps you work better at communicating with the one person who
matters in PE. You. 

In a side note this is a big deal for science and math coding where you
can very often be the only one knows how something works, so this is good
practice 



## Improve (what I'm trying to do)

I'm super slow at these, even the easy ones. I want to get faster, or at
least find you why I'm slow

- look at the problem without a computer, work out what the sticking points might be (can you find the real problem). Set a time limit, note how long you actually spent 
- predict how long it will take to write the code. Were you accurate?
- try
- When you get stuck, note if you got your time/pain point prediction right
- document which types of problems were hardest to write?


### Change

Drilling on these problems is one thing, but unless you're improving, what
is the point? 

Decide waht you need to change?

- Will better tools help?
- A different language? Functional?
- Should you draw more  pictures?
- Will /would an ipython notebook / interpreter / REPL help
- Would compiling help? Typically no
- Should you consider consolidating notes / tooling
- Should you index things more carefully 
- Should you adopt a template for Python code?
- Should you use 
    - virtualenv? 
    - A docker file 
    - vagrant vm? 

Pick something and change it use a control and see what happens


